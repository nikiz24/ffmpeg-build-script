name: FFmpeg Build with Custom Patches

on:
  workflow_dispatch:
    inputs:
      ffmpeg_git_branch:
        description: 'FFmpeg git branch to build'
        required: true
        default: 'release/7.1'
        type: choice
        options:
          - 'release/7.1'
          - 'release/7.0'
          - 'release/6.1'
          - 'master'
          - 'main'
      enable_builds:
        description: 'Select which builds to run'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'darwin-only'
          - 'linux-only'
          - 'darwin-x64-only'
          - 'darwin-arm64-only'
      use_cache:
        description: 'Use build cache to speed up compilation'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      cache_action:
        description: 'Cache management action'
        required: false
        default: 'use'
        type: choice
        options:
          - 'use'
          - 'refresh'
          - 'clean-rebuild'
      git_branch:
        description: 'Git branch for patches'
        required: false
        default: 'main'
        type: string
      patch_clone_url:
        description: 'Private repository URL for patches (leave empty if no patches)'
        required: false
        default: ''
        type: string
      ffmpeg_git_url:
        description: 'FFmpeg git repository URL'
        required: false
        default: 'https://github.com/FFmpeg/FFmpeg.git'
        type: string
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
    types: [ closed ]

env:
  GIT_BRANCH: ${{ github.event.inputs.git_branch || vars.GIT_BRANCH || 'main' }}
  PATCH_CLONE_URL: ${{ github.event.inputs.patch_clone_url || secrets.PATCH_CLONE_URL || '' }}
  FFMPEG_GIT_URL: ${{ github.event.inputs.ffmpeg_git_url || vars.FFMPEG_GIT_URL || 'https://github.com/FFmpeg/FFmpeg.git' }}
  FFMPEG_GIT_BRANCH: ${{ github.event.inputs.ffmpeg_git_branch || vars.FFMPEG_GIT_BRANCH || 'release/7.1' }}

jobs:
  build-macos-x64:
    name: Build macOS x64
    runs-on: macos-15
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event.inputs.enable_builds == 'darwin-x64-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          echo "Building for x64"
          export ARCH=x64
          echo "Cache settings:"
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"

      # 清理缓存（如果选择了 clean-rebuild）
      - name: Clean cache directories
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "🧹 Cleaning cache directories for fresh build..."
          rm -rf packages workspace/lib workspace/include
          # 清理 Homebrew 缓存
          rm -rf ~/Library/Caches/Homebrew
          brew cleanup --prune=all || true

      # 缓存 Homebrew 依赖（根据用户选择）
      - name: Cache Homebrew
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/Cellar
            /usr/local/Homebrew
            ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-homebrew-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('.github/workflows/build-mac-linux.yml') }}
          restore-keys: |
            ${{ runner.os }}-homebrew-

      # 缓存构建包和依赖（根据用户选择）
      - name: Cache build packages
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            packages
            workspace/lib
            workspace/include
          key: ${{ runner.os }}-x64-packages-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-x64-packages-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-x64-packages-

      # 显示缓存状态
      - name: Display cache status
        run: |
          echo "📊 Cache status information:"
          echo "=================================="
          if [[ "${{ github.event.inputs.use_cache }}" == "true" ]]; then
            echo "✅ Cache: ENABLED"
            echo "📋 Action: ${{ github.event.inputs.cache_action }}"
            if [[ -d "packages" ]]; then
              echo "📦 Packages cache: FOUND ($(du -sh packages 2>/dev/null | cut -f1))"
              ls -la packages/ | head -5
            else
              echo "📦 Packages cache: NOT FOUND (fresh build)"
            fi
            if [[ -d "workspace/lib" ]]; then
              echo "🔧 Workspace cache: FOUND ($(du -sh workspace 2>/dev/null | cut -f1))"
            else
              echo "🔧 Workspace cache: NOT FOUND (fresh build)"
            fi
          else
            echo "❌ Cache: DISABLED (fresh build)"
          fi
          echo "=================================="

      - name: Install dependencies
        run: |
          brew update
          brew install automake autoconf libtool pkg-config cmake meson ninja nasm yasm

      - name: Build FFmpeg
        run: |
          chmod +x ./build-ffmpeg
          ./build-ffmpeg --build --enable-gpl-and-non-free

      - name: Extract version information
        id: version
        run: |
          # Get FFmpeg version string
          FFMPEG_VERSION=$(./workspace/bin/ffmpeg -version 2>&1 | head -n 1 | sed 's/ffmpeg version //g' | awk '{print $1}')
          echo "Raw FFmpeg version: $FFMPEG_VERSION"
          
          # Extract version components (handle both release and git versions)
          if [[ "$FFMPEG_VERSION" =~ ^n?([0-9]+\.[0-9]+\.?[0-9]*)-?g?([a-f0-9]*) ]]; then
            VERSION_NUM="${BASH_REMATCH[1]}"
            GIT_HASH="${BASH_REMATCH[2]}"
            if [[ -n "$GIT_HASH" ]]; then
              PACKAGE_VERSION="n${VERSION_NUM}-g${GIT_HASH}"
            else
              PACKAGE_VERSION="n${VERSION_NUM}"
            fi
          else
            # Fallback for different version formats
            PACKAGE_VERSION="${FFMPEG_VERSION}"
          fi
          
          echo "Package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT

      - name: Test run ffmpeg
        run: |
          ./workspace/bin/ffmpeg -buildconf

      - name: Create release package
        run: |
          mkdir -p ./release
          cp workspace/bin/ffmpeg ./release/
          cp workspace/bin/ffprobe ./release/
          cp workspace/bin/ffplay ./release/
          
          # Create version info
          echo "FFmpeg ${{ steps.version.outputs.version }} for Darwin x64" > ./release/README.txt
          echo "Platform: Darwin (macOS)" >> ./release/README.txt
          echo "Architecture: x86_64" >> ./release/README.txt
          echo "Build date: $(date)" >> ./release/README.txt
          echo "FFmpeg branch: ${{ env.FFMPEG_GIT_BRANCH }}" >> ./release/README.txt
          
          # Create packages with proper naming
          PACKAGE_NAME="ffmpeg-${{ steps.version.outputs.version }}-darwin-x64"
          cd ./release
          tar -czf ../${PACKAGE_NAME}.tar.gz *
          zip -r ../${PACKAGE_NAME}.zip *
          cd ..
          
          echo "Created packages:"
          ls -la *.tar.gz *.zip

      - name: Upload x64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-x64
          path: |
            workspace/bin/ffmpeg
            workspace/bin/ffprobe
            workspace/bin/ffplay
          retention-days: 30

      - name: Upload x64 packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-x64-packages
          path: |
            ffmpeg-${{ steps.version.outputs.version }}-darwin-x64.tar.gz
            ffmpeg-${{ steps.version.outputs.version }}-darwin-x64.zip
          retention-days: 30

  build-macos-arm64:
    name: Build macOS ARM64
    runs-on: macos-15
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event.inputs.enable_builds == 'darwin-arm64-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          echo "Building for ARM64"
          export ARCH=arm64
          echo "Cache settings:"
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"

      # 清理缓存（如果选择了 clean-rebuild）
      - name: Clean cache directories
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "🧹 Cleaning cache directories for fresh build..."
          rm -rf packages workspace/lib workspace/include
          # 清理 Homebrew 缓存
          rm -rf ~/Library/Caches/Homebrew
          brew cleanup --prune=all || true

      # 缓存 Homebrew 依赖（根据用户选择）
      - name: Cache Homebrew
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/Cellar
            /usr/local/Homebrew
            ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-homebrew-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('.github/workflows/build-mac-linux.yml') }}
          restore-keys: |
            ${{ runner.os }}-homebrew-

      # 缓存构建包和依赖（根据用户选择）
      - name: Cache build packages
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            packages
            workspace/lib
            workspace/include
          key: ${{ runner.os }}-arm64-packages-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-arm64-packages-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-arm64-packages-

      # 显示缓存状态
      - name: Display cache status
        run: |
          echo "📊 Cache status information:"
          echo "=================================="
          if [[ "${{ github.event.inputs.use_cache }}" == "true" ]]; then
            echo "✅ Cache: ENABLED"
            echo "📋 Action: ${{ github.event.inputs.cache_action }}"
            if [[ -d "packages" ]]; then
              echo "📦 Packages cache: FOUND ($(du -sh packages 2>/dev/null | cut -f1))"
              ls -la packages/ | head -5
            else
              echo "📦 Packages cache: NOT FOUND (fresh build)"
            fi
            if [[ -d "workspace/lib" ]]; then
              echo "🔧 Workspace cache: FOUND ($(du -sh workspace 2>/dev/null | cut -f1))"
            else
              echo "🔧 Workspace cache: NOT FOUND (fresh build)"
            fi
          else
            echo "❌ Cache: DISABLED (fresh build)"
          fi
          echo "=================================="

      - name: Install dependencies
        run: |
          brew update
          brew install automake autoconf libtool pkg-config cmake meson ninja nasm yasm

      - name: Build FFmpeg
        run: |
          chmod +x ./build-ffmpeg
          ./build-ffmpeg --build --enable-gpl-and-non-free

      - name: Extract version information
        id: version
        run: |
          # Get FFmpeg version string
          FFMPEG_VERSION=$(./workspace/bin/ffmpeg -version 2>&1 | head -n 1 | sed 's/ffmpeg version //g' | awk '{print $1}')
          echo "Raw FFmpeg version: $FFMPEG_VERSION"
          
          # Extract version components (handle both release and git versions)
          if [[ "$FFMPEG_VERSION" =~ ^n?([0-9]+\.[0-9]+\.?[0-9]*)-?g?([a-f0-9]*) ]]; then
            VERSION_NUM="${BASH_REMATCH[1]}"
            GIT_HASH="${BASH_REMATCH[2]}"
            if [[ -n "$GIT_HASH" ]]; then
              PACKAGE_VERSION="n${VERSION_NUM}-g${GIT_HASH}"
            else
              PACKAGE_VERSION="n${VERSION_NUM}"
            fi
          else
            # Fallback for different version formats
            PACKAGE_VERSION="${FFMPEG_VERSION}"
          fi
          
          echo "Package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT

      - name: Test run ffmpeg
        run: |
          ./workspace/bin/ffmpeg -buildconf

      - name: Create release package
        run: |
          mkdir -p ./release
          cp workspace/bin/ffmpeg ./release/
          cp workspace/bin/ffprobe ./release/
          cp workspace/bin/ffplay ./release/
          
          # Create version info
          echo "FFmpeg ${{ steps.version.outputs.version }} for Darwin ARM64" > ./release/README.txt
          echo "Platform: Darwin (macOS)" >> ./release/README.txt
          echo "Architecture: arm64" >> ./release/README.txt
          echo "Build date: $(date)" >> ./release/README.txt
          echo "FFmpeg branch: ${{ env.FFMPEG_GIT_BRANCH }}" >> ./release/README.txt
          
          # Create packages with proper naming
          PACKAGE_NAME="ffmpeg-${{ steps.version.outputs.version }}-darwin-arm64"
          cd ./release
          tar -czf ../${PACKAGE_NAME}.tar.gz *
          zip -r ../${PACKAGE_NAME}.zip *
          cd ..
          
          echo "Created packages:"
          ls -la *.tar.gz *.zip

      - name: Upload ARM64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-arm64
          path: |
            workspace/bin/ffmpeg
            workspace/bin/ffprobe
            workspace/bin/ffplay
          retention-days: 30

      - name: Upload ARM64 packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-arm64-packages
          path: |
            ffmpeg-${{ steps.version.outputs.version }}-darwin-arm64.tar.gz
            ffmpeg-${{ steps.version.outputs.version }}-darwin-arm64.zip
          retention-days: 30

  create-universal-macos:
    name: Create Universal macOS Binary
    runs-on: macos-15
    needs: [build-macos-x64, build-macos-arm64]
    if: ${{ always() && needs.build-macos-x64.result == 'success' && needs.build-macos-arm64.result == 'success' && (github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event_name != 'workflow_dispatch') }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download x64 artifacts
        uses: actions/download-artifact@v4
        with:
          name: ffmpeg-macos-x64
          path: ./x64
      
      - name: Download ARM64 artifacts
        uses: actions/download-artifact@v4
        with:
          name: ffmpeg-macos-arm64
          path: ./arm64
      
      - name: Create universal binaries and extract version
        id: universal
        run: |
          mkdir -p ./universal
          
          # Create universal ffmpeg
          lipo -create ./x64/ffmpeg ./arm64/ffmpeg -output ./universal/ffmpeg
          
          # Create universal ffprobe
          lipo -create ./x64/ffprobe ./arm64/ffprobe -output ./universal/ffprobe
          
          # Create universal ffplay
          lipo -create ./x64/ffplay ./arm64/ffplay -output ./universal/ffplay
          
          # Extract version information
          FFMPEG_VERSION=$(./universal/ffmpeg -version 2>&1 | head -n 1 | sed 's/ffmpeg version //g' | awk '{print $1}')
          echo "Raw FFmpeg version: $FFMPEG_VERSION"
          
          # Extract version components (handle both release and git versions)
          if [[ "$FFMPEG_VERSION" =~ ^n?([0-9]+\.[0-9]+\.?[0-9]*)-?g?([a-f0-9]*) ]]; then
            VERSION_NUM="${BASH_REMATCH[1]}"
            GIT_HASH="${BASH_REMATCH[2]}"
            if [[ -n "$GIT_HASH" ]]; then
              PACKAGE_VERSION="n${VERSION_NUM}-g${GIT_HASH}"
            else
              PACKAGE_VERSION="n${VERSION_NUM}"
            fi
          else
            # Fallback for different version formats
            PACKAGE_VERSION="${FFMPEG_VERSION}"
          fi
          
          echo "Package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          
          # Verify universal binaries
          echo "Universal binary information:"
          file ./universal/*
          
          # Test binaries
          ./universal/ffmpeg -version | head -n 1
          ./universal/ffprobe -version | head -n 1
          ./universal/ffplay -version | head -n 1
          
          # Create version info
          echo "FFmpeg $PACKAGE_VERSION Universal Binary for Darwin" > ./universal/README.txt
          echo "Platform: Darwin (macOS)" >> ./universal/README.txt
          echo "Architectures: x86_64, arm64" >> ./universal/README.txt
          echo "Build date: $(date)" >> ./universal/README.txt
          echo "FFmpeg branch: ${{ env.FFMPEG_GIT_BRANCH }}" >> ./universal/README.txt
          
          # Show final package structure
          echo "Final package contents:"
          ls -la ./universal/
      
      - name: Upload universal artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-universal
          path: ./universal/
          retention-days: 30
      
      - name: Create release package
        run: |
          PACKAGE_NAME="ffmpeg-${{ steps.universal.outputs.version }}-darwin-universal"
          cd ./universal
          tar -czf ../${PACKAGE_NAME}.tar.gz *
          zip -r ../${PACKAGE_NAME}.zip *
          cd ..
          
          echo "Release packages created:"
          ls -la *.tar.gz *.zip
      
      - name: Upload release packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-universal-packages
          path: |
            ffmpeg-${{ steps.universal.outputs.version }}-darwin-universal.tar.gz
            ffmpeg-${{ steps.universal.outputs.version }}-darwin-universal.zip
          retention-days: 30

  build-cuda-ubuntu-docker:
    name: Build Ubuntu CUDA Docker
    runs-on: ubuntu-22.04
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'linux-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Free up disk space
        run: |
          rm -rf /usr/share/dotnet && rm -rf /opt/ghc && rm -rf "/usr/local/share/boost"
          rm -rf /opt/hostedtoolcache && cd /opt && find . -maxdepth 1 -mindepth 1 '!' -path ./containerd '!' -path ./actionarchivecache '!' -path ./runner '!' -path ./runner-cache -exec rm -rf '{}' ';'
          docker system prune -af
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      # 清理 Docker 缓存（如果选择了 clean-rebuild）
      - name: Clean Docker cache
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "🧹 Cleaning Docker cache for fresh build..."
          docker system prune -af
          rm -rf /tmp/.buildx-cache
      
      # 设置 Docker Buildx（根据用户选择）
      - name: Set up Docker Buildx
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host
      
      # 缓存 Docker 层（根据用户选择）
      - name: Cache Docker layers
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-cuda-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('cuda-ubuntu.dockerfile', 'build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-buildx-cuda-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-buildx-cuda-
      
      # 显示缓存状态
      - name: Display cache status
        run: |
          echo "📊 Docker cache status:"
          echo "=================================="
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"
          if [[ "${{ github.event.inputs.use_cache }}" == "true" && "${{ github.event.inputs.cache_action }}" != "clean-rebuild" ]]; then
            if [[ -d "/tmp/.buildx-cache" ]]; then
              echo "✅ Docker cache: FOUND ($(du -sh /tmp/.buildx-cache 2>/dev/null | cut -f1))"
            else
              echo "📦 Docker cache: NOT FOUND (fresh build)"
            fi
          else
            echo "❌ Docker cache: DISABLED"
          fi
          echo "=================================="
      
      - name: Pull base image
        id: cuda_ubuntu_pull
        run: |
          docker pull nvidia/cuda:12.6.2-devel-ubuntu22.04
          docker pull ubuntu:22.04
      
      - name: Retry pull if failed
        if: failure() && steps.cuda_ubuntu_pull.outcome == 'failure'
        run: |
          docker pull nvidia/cuda:12.6.2-devel-ubuntu22.04
          docker pull ubuntu:22.04
      
      - name: Build FFmpeg with CUDA
        run: |
          if [[ "${{ github.event.inputs.use_cache }}" == "true" && "${{ github.event.inputs.cache_action }}" != "clean-rebuild" ]]; then
            echo "🚀 Building with cache enabled..."
            docker buildx build \
              --cache-from type=local,src=/tmp/.buildx-cache \
              --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
              --build-arg GIT_BRANCH="${{ env.GIT_BRANCH }}" \
              --build-arg PATCH_CLONE_URL="${{ env.PATCH_CLONE_URL }}" \
              --build-arg FFMPEG_GIT_URL="${{ env.FFMPEG_GIT_URL }}" \
              --build-arg FFMPEG_GIT_BRANCH="${{ env.FFMPEG_GIT_BRANCH }}" \
              --load \
              -t ffmpeg:cuda-ubuntu \
              -f cuda-ubuntu.dockerfile .
          else
            echo "📝 Building without cache (fresh build)..."
            docker build \
              --no-cache \
              --build-arg GIT_BRANCH="${{ env.GIT_BRANCH }}" \
              --build-arg PATCH_CLONE_URL="${{ env.PATCH_CLONE_URL }}" \
              --build-arg FFMPEG_GIT_URL="${{ env.FFMPEG_GIT_URL }}" \
              --build-arg FFMPEG_GIT_BRANCH="${{ env.FFMPEG_GIT_BRANCH }}" \
              -t ffmpeg:cuda-ubuntu \
              -f cuda-ubuntu.dockerfile .
          fi
      
      # 更新缓存（仅在使用缓存时）
      - name: Move cache
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      
      - name: Test run ffmpeg
        run: |
          docker run --rm ffmpeg:cuda-ubuntu -buildconf
      
      - name: Extract binaries and version from Docker
        id: version
        run: |
          mkdir -p ./cuda-ubuntu-artifacts
          docker create --name temp-container ffmpeg:cuda-ubuntu
          docker cp temp-container:/usr/bin/ffmpeg ./cuda-ubuntu-artifacts/
          docker cp temp-container:/usr/bin/ffprobe ./cuda-ubuntu-artifacts/
          docker cp temp-container:/usr/bin/ffplay ./cuda-ubuntu-artifacts/ 2>/dev/null || echo "ffplay not found"
          
          # Extract version information
          FFMPEG_VERSION=$(./cuda-ubuntu-artifacts/ffmpeg -version 2>&1 | head -n 1 | sed 's/ffmpeg version //g' | awk '{print $1}')
          echo "Raw FFmpeg version: $FFMPEG_VERSION"
          
          # Extract version components (handle both release and git versions)
          if [[ "$FFMPEG_VERSION" =~ ^n?([0-9]+\.[0-9]+\.?[0-9]*)-?g?([a-f0-9]*) ]]; then
            VERSION_NUM="${BASH_REMATCH[1]}"
            GIT_HASH="${BASH_REMATCH[2]}"
            if [[ -n "$GIT_HASH" ]]; then
              PACKAGE_VERSION="n${VERSION_NUM}-g${GIT_HASH}"
            else
              PACKAGE_VERSION="n${VERSION_NUM}"
            fi
          else
            # Fallback for different version formats
            PACKAGE_VERSION="${FFMPEG_VERSION}"
          fi
          
          echo "Package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          
          # Create version info
          echo "FFmpeg $PACKAGE_VERSION for Linux x64 with CUDA" > ./cuda-ubuntu-artifacts/README.txt
          echo "Architecture: x86_64" >> ./cuda-ubuntu-artifacts/README.txt
          echo "Features: CUDA acceleration" >> ./cuda-ubuntu-artifacts/README.txt
          echo "Build date: $(date)" >> ./cuda-ubuntu-artifacts/README.txt
          echo "FFmpeg branch: ${{ env.FFMPEG_GIT_BRANCH }}" >> ./cuda-ubuntu-artifacts/README.txt
          
          docker rm temp-container

      - name: Create release package
        run: |
          PACKAGE_NAME="ffmpeg-${{ steps.version.outputs.version }}-linux-amd64"
          cd ./cuda-ubuntu-artifacts
          tar -czf ../${PACKAGE_NAME}.tar.gz *
          zip -r ../${PACKAGE_NAME}.zip *
          cd ..
          
          echo "Created packages:"
          ls -la *.tar.gz *.zip
      
      - name: Upload CUDA Ubuntu artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-cuda-ubuntu
          path: ./cuda-ubuntu-artifacts/
          retention-days: 30

      - name: Upload CUDA Ubuntu packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-cuda-ubuntu-packages
          path: |
            ffmpeg-${{ steps.version.outputs.version }}-linux-amd64.tar.gz
            ffmpeg-${{ steps.version.outputs.version }}-linux-amd64.zip
          retention-days: 30