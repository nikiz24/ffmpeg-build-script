name: FFmpeg Build with Custom Patches
name: FFmpeg Build with Custom Patches

on:
  workflow_dispatch:
    inputs:
      ffmpeg_git_branch:
        description: 'FFmpeg git branch to build'
        required: true
        default: 'release/7.1'
        type: choice
        options:
          - 'release/8.0'
          - 'release/7.1'
          - 'release/7.0'
          - 'release/6.1'
          - 'master'
          - 'main'
      enable_builds:
        description: 'Select which builds to run'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'darwin-only'
          - 'linux-only'
          - 'darwin-x64-only'
          - 'darwin-arm64-only'
      use_cache:
        description: 'Use build cache to speed up compilation'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      cache_action:
        description: 'Cache management action'
        required: false
        default: 'use'
        type: choice
        options:
          - 'use'
          - 'refresh'
          - 'clean-rebuild'
      git_branch:
        description: 'Git branch for patches'
        required: false
        default: 'main'
        type: string
      patch_clone_url:
        description: 'Private repository URL for patches (leave empty if no patches)'
        required: false
        default: ''
        type: string
      ffmpeg_git_url:
        description: 'FFmpeg git repository URL'
        required: false
        default: 'https://github.com/FFmpeg/FFmpeg.git'
        type: string
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
    types: [ closed ]

env:
  GIT_BRANCH: ${{ github.event.inputs.git_branch || vars.GIT_BRANCH || 'main' }}
  PATCH_CLONE_URL: ${{ github.event.inputs.patch_clone_url || secrets.PATCH_CLONE_URL || '' }}
  FFMPEG_GIT_URL: ${{ github.event.inputs.ffmpeg_git_url || vars.FFMPEG_GIT_URL || 'https://github.com/FFmpeg/FFmpeg.git' }}
  FFMPEG_GIT_BRANCH: ${{ github.event.inputs.ffmpeg_git_branch || vars.FFMPEG_GIT_BRANCH || 'release/7.1' }}

jobs:
  build-macos-x64:
    name: Build macOS x64
    runs-on: macos-13  # Intel x64 Êû∂ÊûÑ
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event.inputs.enable_builds == 'darwin-x64-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          echo "Building for x64 on Intel runner"
          echo "Current system info:"
          uname -m  # Â∫îËØ•ÊòæÁ§∫ x86_64
          sysctl -n machdep.cpu.brand_string
          echo "Cache settings:"
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"
          echo "- Target architecture: x86_64 (native)"

      # Ê∏ÖÁêÜÁºìÂ≠òÔºàÂ¶ÇÊûúÈÄâÊã©‰∫Ü clean-rebuildÔºâ
      - name: Clean cache directories
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "üßπ Cleaning cache directories for fresh build..."
          rm -rf packages workspace/lib workspace/include
          # Ê∏ÖÁêÜ Homebrew ÁºìÂ≠ò
          rm -rf ~/Library/Caches/Homebrew
          brew cleanup --prune=all || true

      # ÁºìÂ≠ò Homebrew ‰æùËµñÔºàÊ†πÊçÆÁî®Êà∑ÈÄâÊã©Ôºâ
      - name: Cache Homebrew
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/Cellar
            /usr/local/Homebrew
            ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-homebrew-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('.github/workflows/build-mac-linux.yml') }}
          restore-keys: |
            ${{ runner.os }}-homebrew-

      # ÁºìÂ≠òÊûÑÂª∫ÂåÖÂíå‰æùËµñÔºàÊ†πÊçÆÁî®Êà∑ÈÄâÊã©Ôºâ
      - name: Cache build packages
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            packages
            workspace/lib
            workspace/include
          key: ${{ runner.os }}-x64-packages-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-x64-packages-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-x64-packages-

      # ÊòæÁ§∫ÁºìÂ≠òÁä∂ÊÄÅ
      - name: Display cache status
        run: |
          echo "üìä Cache status information:"
          echo "=================================="
          if [[ "${{ github.event.inputs.use_cache }}" == "true" ]]; then
            echo "‚úÖ Cache: ENABLED"
            echo "üìã Action: ${{ github.event.inputs.cache_action }}"
            if [[ -d "packages" ]]; then
              echo "üì¶ Packages cache: FOUND ($(du -sh packages 2>/dev/null | cut -f1))"
              ls -la packages/ | head -5
            else
              echo "üì¶ Packages cache: NOT FOUND (fresh build)"
            fi
            if [[ -d "workspace/lib" ]]; then
              echo "üîß Workspace cache: FOUND ($(du -sh workspace 2>/dev/null | cut -f1))"
            else
              echo "üîß Workspace cache: NOT FOUND (fresh build)"
            fi
          else
            echo "‚ùå Cache: DISABLED (fresh build)"
          fi
          echo "=================================="

      - name: Install dependencies
        run: |
          brew update
          brew install automake autoconf libtool pkg-config cmake meson ninja nasm yasm

      - name: Build FFmpeg
        run: |
          chmod +x ./build-ffmpeg
          ./build-ffmpeg --build --enable-gpl-and-non-free

      - name: Test run ffmpeg
        run: |
          ./workspace/bin/ffmpeg -buildconf

      - name: Find generated packages
        id: packages
        run: |
          # Find all ffmpeg packages generated by build-ffmpeg script
          PACKAGES=$(ls ffmpeg-*.tar.gz ffmpeg-*.zip 2>/dev/null || true)
          if [[ -z "$PACKAGES" ]]; then
            echo "‚ùå No packages found!"
            exit 1
          fi
          
          echo "üì¶ Found packages:"
          for pkg in $PACKAGES; do
            echo "  - $pkg ($(du -h "$pkg" | cut -f1))"
          done
          
          # Extract version from first package name for outputs
          FIRST_PACKAGE=$(echo $PACKAGES | awk '{print $1}')
          # Extract version from filename: ffmpeg-n7.1.1-g1b48158a23-darwin-x64.tar.gz
          if [[ "$FIRST_PACKAGE" =~ ffmpeg-([^-]+(-g[a-f0-9]{7})?)-.*\.(tar\.gz|zip)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
          else
            VERSION="unknown"
          fi
          
          echo "Extracted version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "packages<<EOF" >> $GITHUB_OUTPUT
          echo "$PACKAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload x64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-x64
          path: |
            workspace/bin/ffmpeg
            workspace/bin/ffprobe
            workspace/bin/ffplay
          retention-days: 30

      - name: Upload x64 packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-x64-packages
          path: ffmpeg-*-darwin-x64.*
          retention-days: 30

  build-macos-arm64:
    name: Build macOS ARM64
    runs-on: macos-15  # Apple Silicon ARM64 Êû∂ÊûÑ
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event.inputs.enable_builds == 'darwin-arm64-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          echo "Building for ARM64 on Apple Silicon runner"
          echo "Current system info:"
          uname -m  # Â∫îËØ•ÊòæÁ§∫ arm64
          sysctl -n machdep.cpu.brand_string
          echo "Cache settings:"
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"
          echo "- Target architecture: arm64 (native)"

      # Ê∏ÖÁêÜÁºìÂ≠òÔºàÂ¶ÇÊûúÈÄâÊã©‰∫Ü clean-rebuildÔºâ
      - name: Clean cache directories
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "üßπ Cleaning cache directories for fresh build..."
          rm -rf packages workspace/lib workspace/include
          # Ê∏ÖÁêÜ Homebrew ÁºìÂ≠ò
          rm -rf ~/Library/Caches/Homebrew
          brew cleanup --prune=all || true

      # ÁºìÂ≠ò Homebrew ‰æùËµñÔºàÊ†πÊçÆÁî®Êà∑ÈÄâÊã©Ôºâ
      - name: Cache Homebrew
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/Cellar
            /usr/local/Homebrew
            ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-homebrew-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('.github/workflows/build-mac-linux.yml') }}
          restore-keys: |
            ${{ runner.os }}-homebrew-

      # ÁºìÂ≠òÊûÑÂª∫ÂåÖÂíå‰æùËµñÔºàÊ†πÊçÆÁî®Êà∑ÈÄâÊã©Ôºâ
      - name: Cache build packages
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            packages
            workspace/lib
            workspace/include
          key: ${{ runner.os }}-arm64-packages-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-arm64-packages-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-arm64-packages-

      # ÊòæÁ§∫ÁºìÂ≠òÁä∂ÊÄÅ
      - name: Display cache status
        run: |
          echo "üìä Cache status information:"
          echo "=================================="
          if [[ "${{ github.event.inputs.use_cache }}" == "true" ]]; then
            echo "‚úÖ Cache: ENABLED"
            echo "üìã Action: ${{ github.event.inputs.cache_action }}"
            if [[ -d "packages" ]]; then
              echo "üì¶ Packages cache: FOUND ($(du -sh packages 2>/dev/null | cut -f1))"
              ls -la packages/ | head -5
            else
              echo "üì¶ Packages cache: NOT FOUND (fresh build)"
            fi
            if [[ -d "workspace/lib" ]]; then
              echo "üîß Workspace cache: FOUND ($(du -sh workspace 2>/dev/null | cut -f1))"
            else
              echo "üîß Workspace cache: NOT FOUND (fresh build)"
            fi
          else
            echo "‚ùå Cache: DISABLED (fresh build)"
          fi
          echo "=================================="

      - name: Install dependencies
        run: |
          brew update
          brew install automake autoconf libtool pkg-config cmake meson ninja nasm yasm

      - name: Build FFmpeg
        run: |
          chmod +x ./build-ffmpeg
          ./build-ffmpeg --build --enable-gpl-and-non-free

      - name: Test run ffmpeg
        run: |
          ./workspace/bin/ffmpeg -buildconf

      - name: Find generated packages
        id: packages
        run: |
          # Find all ffmpeg packages generated by build-ffmpeg script
          PACKAGES=$(ls ffmpeg-*.tar.gz ffmpeg-*.zip 2>/dev/null || true)
          if [[ -z "$PACKAGES" ]]; then
            echo "‚ùå No packages found!"
            exit 1
          fi
          
          echo "üì¶ Found packages:"
          for pkg in $PACKAGES; do
            echo "  - $pkg ($(du -h "$pkg" | cut -f1))"
          done
          
          # Extract version from first package name for outputs
          FIRST_PACKAGE=$(echo $PACKAGES | awk '{print $1}')
          # Extract version from filename: ffmpeg-n7.1.1-g1b48158a23-darwin-arm64.tar.gz
          if [[ "$FIRST_PACKAGE" =~ ffmpeg-([^-]+(-g[a-f0-9]{7})?)-.*\.(tar\.gz|zip)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
          else
            VERSION="unknown"
          fi
          
          echo "Extracted version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "packages<<EOF" >> $GITHUB_OUTPUT
          echo "$PACKAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload ARM64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-arm64
          path: |
            workspace/bin/ffmpeg
            workspace/bin/ffprobe
            workspace/bin/ffplay
          retention-days: 30

      - name: Upload ARM64 packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-arm64-packages
          path: ffmpeg-*-darwin-arm64.*
          retention-days: 30

  create-universal-macos:
    name: Create Universal macOS Binary
    runs-on: macos-15
    needs: [build-macos-x64, build-macos-arm64]
    if: ${{ always() && needs.build-macos-x64.result == 'success' && needs.build-macos-arm64.result == 'success' && (github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event_name != 'workflow_dispatch') }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download x64 artifacts
        uses: actions/download-artifact@v4
        with:
          name: ffmpeg-macos-x64
          path: ./x64
      
      - name: Download ARM64 artifacts
        uses: actions/download-artifact@v4
        with:
          name: ffmpeg-macos-arm64
          path: ./arm64
      
      - name: Create universal binaries and package
        id: universal
        run: |
          mkdir -p ./universal
          
          # Create universal ffmpeg
          lipo -create ./x64/ffmpeg ./arm64/ffmpeg -output ./universal/ffmpeg
          
          # Create universal ffprobe
          lipo -create ./x64/ffprobe ./arm64/ffprobe -output ./universal/ffprobe
          
          # Create universal ffplay
          lipo -create ./x64/ffplay ./arm64/ffplay -output ./universal/ffplay
          
          # Extract version information from binary
          FFMPEG_VERSION=$(./universal/ffmpeg -version 2>&1 | head -n 1 | sed 's/ffmpeg version //g' | awk '{print $1}')
          echo "Raw FFmpeg version: $FFMPEG_VERSION"
          
          # Improved version extraction logic
          if [[ "$FFMPEG_VERSION" =~ ^n?([0-9]+\.[0-9]+(\.[0-9]+)?)-?([0-9]*-)?g?([a-f0-9]+)? ]]; then
            VERSION_NUM="${BASH_REMATCH[1]}"
            GIT_HASH="${BASH_REMATCH[4]}"
            if [[ -n "$GIT_HASH" && ${#GIT_HASH} -ge 7 ]]; then
              PACKAGE_VERSION="n${VERSION_NUM}-g${GIT_HASH:0:7}"
            else
              PACKAGE_VERSION="n${VERSION_NUM}"
            fi
          else
            PACKAGE_VERSION="$FFMPEG_VERSION"
          fi
          
          echo "Package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          
          # Verify universal binaries
          echo "Universal binary information:"
          file ./universal/*
          
          # Test binaries
          ./universal/ffmpeg -version | head -n 1
          ./universal/ffprobe -version | head -n 1
          ./universal/ffplay -version | head -n 1
          
          # Create README
          CURRENT_BRANCH="${{ env.FFMPEG_GIT_BRANCH }}"
          echo "FFmpeg Universal Binary for Darwin" > ./universal/README.txt
          echo "" >> ./universal/README.txt
          echo "Platform: Darwin (macOS)" >> ./universal/README.txt
          echo "Architectures: x86_64, arm64" >> ./universal/README.txt
          echo "Build date: \$(date)" >> ./universal/README.txt
          echo "FFmpeg branch: ${CURRENT_BRANCH}" >> ./universal/README.txt
          echo "" >> ./universal/README.txt
          echo "Binaries included:" >> ./universal/README.txt
          echo "- ffmpeg: Main FFmpeg binary" >> ./universal/README.txt
          echo "- ffprobe: Media analysis tool" >> ./universal/README.txt
          echo "- ffplay: Media player" >> ./universal/README.txt
          echo "" >> ./universal/README.txt
          echo "For more information, visit:" >> ./universal/README.txt
          echo "https://github.com/markus-perl/ffmpeg-build-script" >> ./universal/README.txt
          
          # Create packages with standardized naming
          PACKAGE_BASE_NAME="ffmpeg-${PACKAGE_VERSION}-darwin-universal"
          echo "Creating packages: $PACKAGE_BASE_NAME"
          
          # Create tar.gz package
          tar -czf "../${PACKAGE_BASE_NAME}.tar.gz" *
          
          # Create zip package  
          zip -r "../${PACKAGE_BASE_NAME}.zip" *
          
          cd ..
          
          echo "‚úÖ Successfully created universal packages:"
          echo "   üìÅ ${PACKAGE_BASE_NAME}.tar.gz ($(du -h "${PACKAGE_BASE_NAME}.tar.gz" | cut -f1))"
          echo "   üìÅ ${PACKAGE_BASE_NAME}.zip ($(du -h "${PACKAGE_BASE_NAME}.zip" | cut -f1))"
          
          # Show final package structure
          echo "Final package contents:"
          ls -la ./universal/
      
      - name: Upload universal artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-universal
          path: ./universal/
          retention-days: 30
      
      - name: Upload universal packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-universal-packages
          path: ffmpeg-*-darwin-universal.*
          retention-days: 30

  build-cuda-ubuntu-docker:
    name: Build Ubuntu CUDA Docker
    runs-on: ubuntu-22.04
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'linux-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Free up disk space
        run: |
          rm -rf /usr/share/dotnet && rm -rf /opt/ghc && rm -rf "/usr/local/share/boost"
          rm -rf /opt/hostedtoolcache && cd /opt && find . -maxdepth 1 -mindepth 1 '!' -path ./containerd '!' -path ./actionarchivecache '!' -path ./runner '!' -path ./runner-cache -exec rm -rf '{}' ';'
          docker system prune -af
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      # Ê∏ÖÁêÜ Docker ÁºìÂ≠òÔºàÂ¶ÇÊûúÈÄâÊã©‰∫Ü clean-rebuildÔºâ
      - name: Clean Docker cache
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "üßπ Cleaning Docker cache for fresh build..."
          docker system prune -af
          rm -rf /tmp/.buildx-cache
      
      # ËÆæÁΩÆ Docker BuildxÔºàÊ†πÊçÆÁî®Êà∑ÈÄâÊã©Ôºâ
      - name: Set up Docker Buildx
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host
      
      # ÁºìÂ≠ò Docker Â±ÇÔºàÊ†πÊçÆÁî®Êà∑ÈÄâÊã©Ôºâ
      - name: Cache Docker layers
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-cuda-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('cuda-ubuntu.dockerfile', 'build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-buildx-cuda-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-buildx-cuda-
      
      # ÊòæÁ§∫ÁºìÂ≠òÁä∂ÊÄÅ
      - name: Display cache status
        run: |
          echo "üìä Docker cache status:"
          echo "=================================="
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"
          if [[ "${{ github.event.inputs.use_cache }}" == "true" && "${{ github.event.inputs.cache_action }}" != "clean-rebuild" ]]; then
            if [[ -d "/tmp/.buildx-cache" ]]; then
              echo "‚úÖ Docker cache: FOUND ($(du -sh /tmp/.buildx-cache 2>/dev/null | cut -f1))"
            else
              echo "üì¶ Docker cache: NOT FOUND (fresh build)"
            fi
          else
            echo "‚ùå Docker cache: DISABLED"
          fi
          echo "=================================="
      
      - name: Pull base image
        id: cuda_ubuntu_pull
        run: |
          docker pull nvidia/cuda:12.6.2-devel-ubuntu22.04
          docker pull ubuntu:22.04
      
      - name: Retry pull if failed
        if: failure() && steps.cuda_ubuntu_pull.outcome == 'failure'
        run: |
          docker pull nvidia/cuda:12.6.2-devel-ubuntu22.04
          docker pull ubuntu:22.04
      
      - name: Build FFmpeg with CUDA
        run: |
          if [[ "${{ github.event.inputs.use_cache }}" == "true" && "${{ github.event.inputs.cache_action }}" != "clean-rebuild" ]]; then
            echo "üöÄ Building with cache enabled..."
            docker buildx build \
              --cache-from type=local,src=/tmp/.buildx-cache \
              --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
              --build-arg GIT_BRANCH="${{ env.GIT_BRANCH }}" \
              --build-arg PATCH_CLONE_URL="${{ env.PATCH_CLONE_URL }}" \
              --build-arg FFMPEG_GIT_URL="${{ env.FFMPEG_GIT_URL }}" \
              --build-arg FFMPEG_GIT_BRANCH="${{ env.FFMPEG_GIT_BRANCH }}" \
              --load \
              -t ffmpeg:cuda-ubuntu \
              -f cuda-ubuntu.dockerfile .
          else
            echo "üìù Building without cache (fresh build)..."
            docker build \
              --no-cache \
              --build-arg GIT_BRANCH="${{ env.GIT_BRANCH }}" \
              --build-arg PATCH_CLONE_URL="${{ env.PATCH_CLONE_URL }}" \
              --build-arg FFMPEG_GIT_URL="${{ env.FFMPEG_GIT_URL }}" \
              --build-arg FFMPEG_GIT_BRANCH="${{ env.FFMPEG_GIT_BRANCH }}" \
              -t ffmpeg:cuda-ubuntu \
              -f cuda-ubuntu.dockerfile .
          fi
      
      # Êõ¥Êñ∞ÁºìÂ≠òÔºà‰ªÖÂú®‰ΩøÁî®ÁºìÂ≠òÊó∂Ôºâ
      - name: Move cache
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      
      - name: Test run ffmpeg
        run: |
          docker run --rm ffmpeg:cuda-ubuntu -buildconf
      
      - name: Extract binaries and create packages
        id: packages
        run: |
          mkdir -p ./cuda-ubuntu-artifacts
          docker create --name temp-container ffmpeg:cuda-ubuntu
          docker cp temp-container:/usr/bin/ffmpeg ./cuda-ubuntu-artifacts/
          docker cp temp-container:/usr/bin/ffprobe ./cuda-ubuntu-artifacts/
          docker cp temp-container:/usr/bin/ffplay ./cuda-ubuntu-artifacts/ 2>/dev/null || echo "ffplay not found"
          
          # Extract version information
          FFMPEG_VERSION=$(./cuda-ubuntu-artifacts/ffmpeg -version 2>&1 | head -n 1 | sed 's/ffmpeg version //g' | awk '{print $1}')
          echo "Raw FFmpeg version: $FFMPEG_VERSION"
          
          # Improved version extraction logic
          if [[ "$FFMPEG_VERSION" =~ ^n?([0-9]+\.[0-9]+(\.[0-9]+)?)-?([0-9]*-)?g?([a-f0-9]+)? ]]; then
            VERSION_NUM="${BASH_REMATCH[1]}"
            GIT_HASH="${BASH_REMATCH[4]}"
            if [[ -n "$GIT_HASH" && ${#GIT_HASH} -ge 7 ]]; then
              PACKAGE_VERSION="n${VERSION_NUM}-g${GIT_HASH:0:7}"
            else
              PACKAGE_VERSION="n${VERSION_NUM}"
            fi
          else
            PACKAGE_VERSION="$FFMPEG_VERSION"
          fi
          
          echo "Package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          
          # Create README with build information
          CURRENT_BRANCH="${{ env.FFMPEG_GIT_BRANCH }}"
          echo "FFmpeg for Linux amd64 with CUDA" > ./cuda-ubuntu-artifacts/README.txt
          echo "" >> ./cuda-ubuntu-artifacts/README.txt
          echo "Platform: Linux" >> ./cuda-ubuntu-artifacts/README.txt
          echo "Architecture: amd64" >> ./cuda-ubuntu-artifacts/README.txt
          echo "Features: CUDA acceleration" >> ./cuda-ubuntu-artifacts/README.txt
          echo "Build date: \$(date)" >> ./cuda-ubuntu-artifacts/README.txt
          echo "FFmpeg branch: ${CURRENT_BRANCH}" >> ./cuda-ubuntu-artifacts/README.txt
          echo "" >> ./cuda-ubuntu-artifacts/README.txt
          echo "Binaries included:" >> ./cuda-ubuntu-artifacts/README.txt
          echo "- ffmpeg: Main FFmpeg binary with CUDA support" >> ./cuda-ubuntu-artifacts/README.txt
          echo "- ffprobe: Media analysis tool" >> ./cuda-ubuntu-artifacts/README.txt
          echo "- ffplay: Media player (if available)" >> ./cuda-ubuntu-artifacts/README.txt
          echo "" >> ./cuda-ubuntu-artifacts/README.txt
          echo "For more information, visit:" >> ./cuda-ubuntu-artifacts/README.txt
          echo "https://github.com/markus-perl/ffmpeg-build-script" >> ./cuda-ubuntu-artifacts/README.txt
          
          # Create packages with standardized naming
          PACKAGE_BASE_NAME="ffmpeg-${PACKAGE_VERSION}-linux-amd64"
          echo "Creating packages: $PACKAGE_BASE_NAME"
          
          # Create tar.gz package
          cd ./cuda-ubuntu-artifacts
          tar -czf "../${PACKAGE_BASE_NAME}.tar.gz" *
          
          # Create zip package  
          zip -r "../${PACKAGE_BASE_NAME}.zip" *
          
          cd ..
          
          echo "‚úÖ Successfully created CUDA packages:"
          echo "   üìÅ ${PACKAGE_BASE_NAME}.tar.gz ($(du -h "${PACKAGE_BASE_NAME}.tar.gz" | cut -f1))"
          echo "   üìÅ ${PACKAGE_BASE_NAME}.zip ($(du -h "${PACKAGE_BASE_NAME}.zip" | cut -f1))"
          
          docker rm temp-container
      
      - name: Upload CUDA Ubuntu artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-cuda-ubuntu
          path: ./cuda-ubuntu-artifacts/
          retention-days: 30

      - name: Upload CUDA Ubuntu packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-cuda-ubuntu-packages
          path: ffmpeg-*-linux-amd64.*
          retention-days: 30