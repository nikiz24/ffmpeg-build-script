name: FFmpeg Build with Custom Patches

on:
  workflow_dispatch:
    inputs:
      ffmpeg_git_branch:
        description: 'FFmpeg git branch to build'
        required: true
        default: 'release/7.1'
        type: choice
        options:
          - 'release/8.0'
          - 'release/7.1'
          - 'release/7.0'
          - 'release/6.1'
          - 'master'
          - 'main'
      enable_builds:
        description: 'Select which builds to run'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'darwin-only'
          - 'linux-only'
          - 'darwin-x64-only'
          - 'darwin-arm64-only'
      use_cache:
        description: 'Use build cache to speed up compilation'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      cache_action:
        description: 'Cache management action'
        required: false
        default: 'use'
        type: choice
        options:
          - 'use'
          - 'refresh'
          - 'clean-rebuild'
      git_branch:
        description: 'Git branch for patches'
        required: false
        default: 'main'
        type: string
      patch_clone_url:
        description: 'Private repository URL for patches (leave empty if no patches)'
        required: false
        default: ''
        type: string
      ffmpeg_git_url:
        description: 'FFmpeg git repository URL'
        required: false
        default: 'https://github.com/FFmpeg/FFmpeg.git'
        type: string
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
    types: [ closed ]

env:
  GIT_BRANCH: ${{ github.event.inputs.git_branch || vars.GIT_BRANCH || 'main' }}
  PATCH_CLONE_URL: ${{ github.event.inputs.patch_clone_url || secrets.PATCH_CLONE_URL || '' }}
  FFMPEG_GIT_URL: ${{ github.event.inputs.ffmpeg_git_url || vars.FFMPEG_GIT_URL || 'https://github.com/FFmpeg/FFmpeg.git' }}
  FFMPEG_GIT_BRANCH: ${{ github.event.inputs.ffmpeg_git_branch || vars.FFMPEG_GIT_BRANCH || 'release/7.1' }}

jobs:
  build-macos-x64:
    name: Build macOS x64
    runs-on: macos-13  # Intel x64 æž¶æž„
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event.inputs.enable_builds == 'darwin-x64-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          echo "Building for x64 on Intel runner"
          echo "Current system info:"
          uname -m  # åº”è¯¥æ˜¾ç¤º x86_64
          sysctl -n machdep.cpu.brand_string
          echo "Cache settings:"
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"
          echo "- Target architecture: x86_64 (native)"

      # æ¸…ç†ç¼“å­˜ï¼ˆå¦‚æžœé€‰æ‹©äº† clean-rebuildï¼‰
      - name: Clean cache directories
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "ðŸ§¹ Cleaning cache directories for fresh build..."
          rm -rf packages workspace/lib workspace/include
          # æ¸…ç† Homebrew ç¼“å­˜
          rm -rf ~/Library/Caches/Homebrew
          brew cleanup --prune=all || true

      # ç¼“å­˜ Homebrew ä¾èµ–ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
      - name: Cache Homebrew
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/Cellar
            /usr/local/Homebrew
            ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-homebrew-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('.github/workflows/build-mac-linux.yml') }}
          restore-keys: |
            ${{ runner.os }}-homebrew-

      # ç¼“å­˜æž„å»ºåŒ…å’Œä¾èµ–ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
      - name: Cache build packages
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            packages
            workspace/lib
            workspace/include
          key: ${{ runner.os }}-x64-packages-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-x64-packages-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-x64-packages-

      # æ˜¾ç¤ºç¼“å­˜çŠ¶æ€
      - name: Display cache status
        run: |
          echo "ðŸ“Š Cache status information:"
          echo "=================================="
          if [[ "${{ github.event.inputs.use_cache }}" == "true" ]]; then
            echo "âœ… Cache: ENABLED"
            echo "ðŸ“‹ Action: ${{ github.event.inputs.cache_action }}"
            if [[ -d "packages" ]]; then
              echo "ðŸ“¦ Packages cache: FOUND ($(du -sh packages 2>/dev/null | cut -f1))"
              ls -la packages/ | head -5
            else
              echo "ðŸ“¦ Packages cache: NOT FOUND (fresh build)"
            fi
            if [[ -d "workspace/lib" ]]; then
              echo "ðŸ”§ Workspace cache: FOUND ($(du -sh workspace 2>/dev/null | cut -f1))"
            else
              echo "ðŸ”§ Workspace cache: NOT FOUND (fresh build)"
            fi
          else
            echo "âŒ Cache: DISABLED (fresh build)"
          fi
          echo "=================================="

      - name: Install dependencies
        run: |
          brew update
          brew install automake autoconf libtool pkg-config cmake meson ninja nasm yasm

      - name: Build FFmpeg
        run: |
          chmod +x ./build-ffmpeg
          ./build-ffmpeg --build --enable-gpl-and-non-free

      - name: Test run ffmpeg
        run: |
          ./workspace/bin/ffmpeg -buildconf

      - name: Find generated packages
        id: packages
        run: |
          # Find all ffmpeg packages generated by build-ffmpeg script
          PACKAGES=$(ls ffmpeg-*.tar.gz ffmpeg-*.zip 2>/dev/null || true)
          if [[ -z "$PACKAGES" ]]; then
            echo "âŒ No packages found!"
            exit 1
          fi
          
          echo "ðŸ“¦ Found packages:"
          for pkg in $PACKAGES; do
            echo "  - $pkg ($(du -h "$pkg" | cut -f1))"
          done
          
          # Extract version from first package name for outputs
          FIRST_PACKAGE=$(echo $PACKAGES | awk '{print $1}')
          # Extract version from filename: ffmpeg-n7.1.1-g1b48158a23-darwin-x64.tar.gz
          if [[ "$FIRST_PACKAGE" =~ ffmpeg-([^-]+(-g[a-f0-9]{7})?)-.*\.(tar\.gz|zip)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
          else
            VERSION="unknown"
          fi
          
          echo "Extracted version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "packages<<EOF" >> $GITHUB_OUTPUT
          echo "$PACKAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload x64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-x64
          path: |
            workspace/bin/ffmpeg
            workspace/bin/ffprobe
            workspace/bin/ffplay
          retention-days: 30

      - name: Upload x64 packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-x64-packages
          path: ffmpeg-*-darwin-x64.*
          retention-days: 30

  build-macos-arm64:
    name: Build macOS ARM64
    runs-on: macos-15  # Apple Silicon ARM64 æž¶æž„
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event.inputs.enable_builds == 'darwin-arm64-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up environment
        run: |
          echo "Building for ARM64 on Apple Silicon runner"
          echo "Current system info:"
          uname -m  # åº”è¯¥æ˜¾ç¤º arm64
          sysctl -n machdep.cpu.brand_string
          echo "Cache settings:"
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"
          echo "- Target architecture: arm64 (native)"

      # æ¸…ç†ç¼“å­˜ï¼ˆå¦‚æžœé€‰æ‹©äº† clean-rebuildï¼‰
      - name: Clean cache directories
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "ðŸ§¹ Cleaning cache directories for fresh build..."
          rm -rf packages workspace/lib workspace/include
          # æ¸…ç† Homebrew ç¼“å­˜
          rm -rf ~/Library/Caches/Homebrew
          brew cleanup --prune=all || true

      # ç¼“å­˜ Homebrew ä¾èµ–ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
      - name: Cache Homebrew
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            /usr/local/Cellar
            /usr/local/Homebrew
            ~/Library/Caches/Homebrew
          key: ${{ runner.os }}-homebrew-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('.github/workflows/build-mac-linux.yml') }}
          restore-keys: |
            ${{ runner.os }}-homebrew-

      # ç¼“å­˜æž„å»ºåŒ…å’Œä¾èµ–ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
      - name: Cache build packages
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: |
            packages
            workspace/lib
            workspace/include
          key: ${{ runner.os }}-arm64-packages-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-arm64-packages-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-arm64-packages-

      # æ˜¾ç¤ºç¼“å­˜çŠ¶æ€
      - name: Display cache status
        run: |
          echo "ðŸ“Š Cache status information:"
          echo "=================================="
          if [[ "${{ github.event.inputs.use_cache }}" == "true" ]]; then
            echo "âœ… Cache: ENABLED"
            echo "ðŸ“‹ Action: ${{ github.event.inputs.cache_action }}"
            if [[ -d "packages" ]]; then
              echo "ðŸ“¦ Packages cache: FOUND ($(du -sh packages 2>/dev/null | cut -f1))"
              ls -la packages/ | head -5
            else
              echo "ðŸ“¦ Packages cache: NOT FOUND (fresh build)"
            fi
            if [[ -d "workspace/lib" ]]; then
              echo "ðŸ”§ Workspace cache: FOUND ($(du -sh workspace 2>/dev/null | cut -f1))"
            else
              echo "ðŸ”§ Workspace cache: NOT FOUND (fresh build)"
            fi
          else
            echo "âŒ Cache: DISABLED (fresh build)"
          fi
          echo "=================================="

      - name: Install dependencies
        run: |
          brew update
          brew install automake autoconf libtool pkg-config cmake meson ninja nasm yasm

      - name: Build FFmpeg
        run: |
          chmod +x ./build-ffmpeg
          ./build-ffmpeg --build --enable-gpl-and-non-free

      - name: Test run ffmpeg
        run: |
          ./workspace/bin/ffmpeg -buildconf

      - name: Find generated packages
        id: packages
        run: |
          # Find all ffmpeg packages generated by build-ffmpeg script
          PACKAGES=$(ls ffmpeg-*.tar.gz ffmpeg-*.zip 2>/dev/null || true)
          if [[ -z "$PACKAGES" ]]; then
            echo "âŒ No packages found!"
            exit 1
          fi
          
          echo "ðŸ“¦ Found packages:"
          for pkg in $PACKAGES; do
            echo "  - $pkg ($(du -h "$pkg" | cut -f1))"
          done
          
          # Extract version from first package name for outputs
          FIRST_PACKAGE=$(echo $PACKAGES | awk '{print $1}')
          # Extract version from filename: ffmpeg-n7.1.1-g1b48158a23-darwin-arm64.tar.gz
          if [[ "$FIRST_PACKAGE" =~ ffmpeg-([^-]+(-g[a-f0-9]{7})?)-.*\.(tar\.gz|zip)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
          else
            VERSION="unknown"
          fi
          
          echo "Extracted version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "packages<<EOF" >> $GITHUB_OUTPUT
          echo "$PACKAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Upload ARM64 artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-arm64
          path: |
            workspace/bin/ffmpeg
            workspace/bin/ffprobe
            workspace/bin/ffplay
          retention-days: 30

      - name: Upload ARM64 packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-arm64-packages
          path: ffmpeg-*-darwin-arm64.*
          retention-days: 30

  create-universal-macos:
    name: Create Universal macOS Binary
    runs-on: macos-15
    needs: [build-macos-x64, build-macos-arm64]
    if: ${{ always() && needs.build-macos-x64.result == 'success' && needs.build-macos-arm64.result == 'success' && (github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'darwin-only' || github.event_name != 'workflow_dispatch') }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download x64 artifacts
        uses: actions/download-artifact@v4
        with:
          name: ffmpeg-macos-x64
          path: ./x64
      
      - name: Download ARM64 artifacts
        uses: actions/download-artifact@v4
        with:
          name: ffmpeg-macos-arm64
          path: ./arm64
      
      - name: Create universal binaries and package
        id: universal
        run: |
          mkdir -p ./universal
          
          # Create universal ffmpeg
          lipo -create ./x64/ffmpeg ./arm64/ffmpeg -output ./universal/ffmpeg
          
          # Create universal ffprobe
          lipo -create ./x64/ffprobe ./arm64/ffprobe -output ./universal/ffprobe
          
          # Create universal ffplay
          lipo -create ./x64/ffplay ./arm64/ffplay -output ./universal/ffplay
          
          # Extract version information from binary
          FFMPEG_VERSION=$(./universal/ffmpeg -version 2>&1 | head -n 1 | sed 's/ffmpeg version //g' | awk '{print $1}')
          echo "Raw FFmpeg version: $FFMPEG_VERSION"
          
          # Improved version extraction logic
          if [[ "$FFMPEG_VERSION" =~ ^n?([0-9]+\.[0-9]+(\.[0-9]+)?)-?([0-9]*-)?g?([a-f0-9]+)? ]]; then
            VERSION_NUM="${BASH_REMATCH[1]}"
            GIT_HASH="${BASH_REMATCH[4]}"
            if [[ -n "$GIT_HASH" && ${#GIT_HASH} -ge 7 ]]; then
              PACKAGE_VERSION="n${VERSION_NUM}-g${GIT_HASH:0:7}"
            else
              PACKAGE_VERSION="n${VERSION_NUM}"
            fi
          else
            PACKAGE_VERSION="$FFMPEG_VERSION"
          fi
          
          echo "Package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          
          # Verify universal binaries
          echo "Universal binary information:"
          file ./universal/*
          
          # Test binaries
          ./universal/ffmpeg -version | head -n 1
          ./universal/ffprobe -version | head -n 1
          ./universal/ffplay -version | head -n 1
          
          # Create README
          cat > ./universal/README.txt << EOF
FFmpeg $PACKAGE_VERSION Universal Binary for Darwin

Platform: Darwin (macOS)
Architectures: x86_64, arm64
Build date: $(date)
FFmpeg branch: ${{ env.FFMPEG_GIT_BRANCH }}

Binaries included:
- ffmpeg: Main FFmpeg binary
- ffprobe: Media analysis tool
- ffplay: Media player

For more information, visit:
https://github.com/markus-perl/ffmpeg-build-script
EOF
          
          # Create packages with standardized naming
          PACKAGE_BASE_NAME="ffmpeg-${PACKAGE_VERSION}-darwin-universal"
          echo "Creating packages: $PACKAGE_BASE_NAME"
          
          # Create tar.gz package
          tar -czf "../${PACKAGE_BASE_NAME}.tar.gz" *
          
          # Create zip package  
          zip -r "../${PACKAGE_BASE_NAME}.zip" *
          
          cd ..
          
          echo "âœ… Successfully created universal packages:"
          echo "   ðŸ“ ${PACKAGE_BASE_NAME}.tar.gz ($(du -h "${PACKAGE_BASE_NAME}.tar.gz" | cut -f1))"
          echo "   ðŸ“ ${PACKAGE_BASE_NAME}.zip ($(du -h "${PACKAGE_BASE_NAME}.zip" | cut -f1))"
          
          # Show final package structure
          echo "Final package contents:"
          ls -la ./universal/
      
      - name: Upload universal artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-macos-universal
          path: ./universal/
          retention-days: 30
      
      - name: Upload universal packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-darwin-universal-packages
          path: ffmpeg-*-darwin-universal.*
          retention-days: 30

  build-cuda-ubuntu-docker:
    name: Build Ubuntu CUDA Docker
    runs-on: ubuntu-22.04
    if: ${{ github.event.inputs.enable_builds == 'all' || github.event.inputs.enable_builds == 'linux-only' || github.event_name != 'workflow_dispatch' }}
    outputs:
      ffmpeg-version: ${{ steps.version.outputs.version }}
    steps:
      - name: Free up disk space
        run: |
          rm -rf /usr/share/dotnet && rm -rf /opt/ghc && rm -rf "/usr/local/share/boost"
          rm -rf /opt/hostedtoolcache && cd /opt && find . -maxdepth 1 -mindepth 1 '!' -path ./containerd '!' -path ./actionarchivecache '!' -path ./runner '!' -path ./runner-cache -exec rm -rf '{}' ';'
          docker system prune -af
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      # æ¸…ç† Docker ç¼“å­˜ï¼ˆå¦‚æžœé€‰æ‹©äº† clean-rebuildï¼‰
      - name: Clean Docker cache
        if: ${{ github.event.inputs.cache_action == 'clean-rebuild' }}
        run: |
          echo "ðŸ§¹ Cleaning Docker cache for fresh build..."
          docker system prune -af
          rm -rf /tmp/.buildx-cache
      
      # è®¾ç½® Docker Buildxï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
      - name: Set up Docker Buildx
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host
      
      # ç¼“å­˜ Docker å±‚ï¼ˆæ ¹æ®ç”¨æˆ·é€‰æ‹©ï¼‰
      - name: Cache Docker layers
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-cuda-${{ env.FFMPEG_GIT_BRANCH }}-${{ github.event.inputs.cache_action == 'refresh' && github.run_number || hashFiles('cuda-ubuntu.dockerfile', 'build-ffmpeg') }}
          restore-keys: |
            ${{ runner.os }}-buildx-cuda-${{ env.FFMPEG_GIT_BRANCH }}-
            ${{ runner.os }}-buildx-cuda-
      
      # æ˜¾ç¤ºç¼“å­˜çŠ¶æ€
      - name: Display cache status
        run: |
          echo "ðŸ“Š Docker cache status:"
          echo "=================================="
          echo "- Use cache: ${{ github.event.inputs.use_cache }}"
          echo "- Cache action: ${{ github.event.inputs.cache_action }}"
          if [[ "${{ github.event.inputs.use_cache }}" == "true" && "${{ github.event.inputs.cache_action }}" != "clean-rebuild" ]]; then
            if [[ -d "/tmp/.buildx-cache" ]]; then
              echo "âœ… Docker cache: FOUND ($(du -sh /tmp/.buildx-cache 2>/dev/null | cut -f1))"
            else
              echo "ðŸ“¦ Docker cache: NOT FOUND (fresh build)"
            fi
          else
            echo "âŒ Docker cache: DISABLED"
          fi
          echo "=================================="
      
      - name: Pull base image
        id: cuda_ubuntu_pull
        run: |
          docker pull nvidia/cuda:12.6.2-devel-ubuntu22.04
          docker pull ubuntu:22.04
      
      - name: Retry pull if failed
        if: failure() && steps.cuda_ubuntu_pull.outcome == 'failure'
        run: |
          docker pull nvidia/cuda:12.6.2-devel-ubuntu22.04
          docker pull ubuntu:22.04
      
      - name: Build FFmpeg with CUDA
        run: |
          if [[ "${{ github.event.inputs.use_cache }}" == "true" && "${{ github.event.inputs.cache_action }}" != "clean-rebuild" ]]; then
            echo "ðŸš€ Building with cache enabled..."
            docker buildx build \
              --cache-from type=local,src=/tmp/.buildx-cache \
              --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
              --build-arg GIT_BRANCH="${{ env.GIT_BRANCH }}" \
              --build-arg PATCH_CLONE_URL="${{ env.PATCH_CLONE_URL }}" \
              --build-arg FFMPEG_GIT_URL="${{ env.FFMPEG_GIT_URL }}" \
              --build-arg FFMPEG_GIT_BRANCH="${{ env.FFMPEG_GIT_BRANCH }}" \
              --load \
              -t ffmpeg:cuda-ubuntu \
              -f cuda-ubuntu.dockerfile .
          else
            echo "ðŸ“ Building without cache (fresh build)..."
            docker build \
              --no-cache \
              --build-arg GIT_BRANCH="${{ env.GIT_BRANCH }}" \
              --build-arg PATCH_CLONE_URL="${{ env.PATCH_CLONE_URL }}" \
              --build-arg FFMPEG_GIT_URL="${{ env.FFMPEG_GIT_URL }}" \
              --build-arg FFMPEG_GIT_BRANCH="${{ env.FFMPEG_GIT_BRANCH }}" \
              -t ffmpeg:cuda-ubuntu \
              -f cuda-ubuntu.dockerfile .
          fi
      
      # æ›´æ–°ç¼“å­˜ï¼ˆä»…åœ¨ä½¿ç”¨ç¼“å­˜æ—¶ï¼‰
      - name: Move cache
        if: ${{ github.event.inputs.use_cache == 'true' && github.event.inputs.cache_action != 'clean-rebuild' }}
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache
      
      - name: Test run ffmpeg
        run: |
          docker run --rm ffmpeg:cuda-ubuntu -buildconf
      
      - name: Extract binaries and create packages
        id: packages
        run: |
          mkdir -p ./cuda-ubuntu-artifacts
          docker create --name temp-container ffmpeg:cuda-ubuntu
          docker cp temp-container:/usr/bin/ffmpeg ./cuda-ubuntu-artifacts/
          docker cp temp-container:/usr/bin/ffprobe ./cuda-ubuntu-artifacts/
          docker cp temp-container:/usr/bin/ffplay ./cuda-ubuntu-artifacts/ 2>/dev/null || echo "ffplay not found"
          
          # Extract version information
          FFMPEG_VERSION=$(./cuda-ubuntu-artifacts/ffmpeg -version 2>&1 | head -n 1 | sed 's/ffmpeg version //g' | awk '{print $1}')
          echo "Raw FFmpeg version: $FFMPEG_VERSION"
          
          # Improved version extraction logic
          if [[ "$FFMPEG_VERSION" =~ ^n?([0-9]+\.[0-9]+(\.[0-9]+)?)-?([0-9]*-)?g?([a-f0-9]+)? ]]; then
            VERSION_NUM="${BASH_REMATCH[1]}"
            GIT_HASH="${BASH_REMATCH[4]}"
            if [[ -n "$GIT_HASH" && ${#GIT_HASH} -ge 7 ]]; then
              PACKAGE_VERSION="n${VERSION_NUM}-g${GIT_HASH:0:7}"
            else
              PACKAGE_VERSION="n${VERSION_NUM}"
            fi
          else
            PACKAGE_VERSION="$FFMPEG_VERSION"
          fi
          
          echo "Package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          
          # Create README with build information
          cat > ./cuda-ubuntu-artifacts/README.txt << EOF
FFmpeg $PACKAGE_VERSION for Linux amd64 with CUDA

Platform: Linux
Architecture: amd64
Features: CUDA acceleration
Build date: $(date)
FFmpeg branch: ${{ env.FFMPEG_GIT_BRANCH }}

Binaries included:
- ffmpeg: Main FFmpeg binary with CUDA support
- ffprobe: Media analysis tool
$(if [[ -f "./cuda-ubuntu-artifacts/ffplay" ]]; then echo "- ffplay: Media player"; fi)

For more information, visit:
https://github.com/markus-perl/ffmpeg-build-script
EOF
          
          # Create packages with standardized naming
          PACKAGE_BASE_NAME="ffmpeg-${PACKAGE_VERSION}-linux-amd64"
          echo "Creating packages: $PACKAGE_BASE_NAME"
          
          # Create tar.gz package
          cd ./cuda-ubuntu-artifacts
          tar -czf "../${PACKAGE_BASE_NAME}.tar.gz" *
          
          # Create zip package  
          zip -r "../${PACKAGE_BASE_NAME}.zip" *
          
          cd ..
          
          echo "âœ… Successfully created CUDA packages:"
          echo "   ðŸ“ ${PACKAGE_BASE_NAME}.tar.gz ($(du -h "${PACKAGE_BASE_NAME}.tar.gz" | cut -f1))"
          echo "   ðŸ“ ${PACKAGE_BASE_NAME}.zip ($(du -h "${PACKAGE_BASE_NAME}.zip" | cut -f1))"
          
          docker rm temp-container
      
      - name: Upload CUDA Ubuntu artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-cuda-ubuntu
          path: ./cuda-ubuntu-artifacts/
          retention-days: 30

      - name: Upload CUDA Ubuntu packages
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-cuda-ubuntu-packages
          path: ffmpeg-*-linux-amd64.*
          retention-days: 30